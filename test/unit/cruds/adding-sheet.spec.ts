/* eslint-disable @typescript-eslint/no-non-null-assertion */
import {ErrorType, HyperFormula, SheetNameAlreadyTakenError} from '../../../src'
import {plPL} from '../../../src/i18n/languages'
import {adr, detailedError} from '../testUtils'

describe('Adding sheet - checking if its possible', () => {
  it('yes', () => {
    const engine = HyperFormula.buildEmpty()

    expect(engine.isItPossibleToAddSheet('Sheet1')).toBe(true)
    expect(engine.isItPossibleToAddSheet('~`!@#$%^&*()_-+_=/|?{}[]\\"')).toBe(true)
  })

  it('no', () => {
    const engine = HyperFormula.buildFromSheets({
      Sheet1: [],
      Foo: [],
    })

    expect(engine.isItPossibleToAddSheet('Sheet1')).toBe(false)
    expect(engine.isItPossibleToAddSheet('Foo')).toBe(false)
  })
})

describe('add sheet to engine', () => {
  it('should add sheet to empty engine', function() {
    const engine = HyperFormula.buildEmpty()

    engine.addSheet()

    expect(engine.sheetMapping.numberOfSheets()).toBe(1)
    expect(Array.from(engine.sheetMapping.iterateSheetNames())).toEqual(['Sheet1'])
  })

  it('should add sheet to engine with one sheet', function() {
    const engine = HyperFormula.buildFromArray([
      ['foo'],
    ])

    engine.addSheet()

    expect(engine.sheetMapping.numberOfSheets()).toBe(2)
    expect(Array.from(engine.sheetMapping.iterateSheetNames())).toEqual(['Sheet1', 'Sheet2'])
  })

  it('should be possible to fetch empty cell from newly added sheet', function() {
    const engine = HyperFormula.buildEmpty()

    engine.addSheet()

    expect(engine.getCellValue(adr('A1', 0))).toBeNull()
  })

  it('should add sheet with translated sheet name', function() {
    HyperFormula.registerLanguage('plPL', plPL)
    const engine = HyperFormula.buildEmpty({language: 'plPL'})

    engine.addSheet()

    expect(engine.sheetMapping.numberOfSheets()).toBe(1)
    expect(Array.from(engine.sheetMapping.iterateSheetNames())).toEqual(['Arkusz1'])
  })

  it('should add sheet with given name', function() {
    const engine = HyperFormula.buildEmpty()

    engine.addSheet('foo')

    expect(engine.sheetMapping.numberOfSheets()).toBe(1)
    expect(Array.from(engine.sheetMapping.iterateSheetNames())).toEqual(['foo'])
  })

  it('cannot add another sheet with same lowercased name', function() {
    const engine = HyperFormula.buildEmpty()
    engine.addSheet('foo')

    expect(() => {
      engine.addSheet('FOO')
    }).toThrowError(/already exists/)

    expect(engine.sheetMapping.numberOfSheets()).toBe(1)
    expect(Array.from(engine.sheetMapping.iterateSheetNames())).toEqual(['foo'])
  })

  it('should return given name', function() {
    const engine = HyperFormula.buildEmpty()

    const sheetName = engine.addSheet('foo')

    expect(sheetName).toBe('foo')

  })

  it('should return autogenerated name', function() {
    const engine = HyperFormula.buildEmpty()

    const sheetName = engine.addSheet()

    expect(sheetName).toBe('Sheet1')
  })

  it('should throw error when sheet name is already taken', () => {
    const engine = HyperFormula.buildEmpty()
    engine.addSheet('bar')

    expect(() => {
      engine.addSheet('bar')
    }).toThrow(new SheetNameAlreadyTakenError('bar'))
  })
})

describe('recalculates formulas after adding new sheet (issue #1116)', () => {
  it('recalculates single cell reference without quotes', () => {
    const  engine = HyperFormula.buildEmpty()
    const table1Name = 'table1'
    const table2Name = 'table2'

    engine.addSheet(table1Name)
    engine.setCellContents(adr('A1', engine.getSheetId(table1Name)), `=${table2Name}!A1`)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(table1Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(table2Name)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(table2Name)))).toBeNull()
    expect(engine.getCellValue(adr('A1', engine.getSheetId(table1Name)))).toBeNull()

    engine.setCellContents(adr('A1', engine.getSheetId(table2Name)), 10)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(table1Name)))).toBe(10)
  })

  it('recalculates single cell reference with quotes', () => {
    const  engine = HyperFormula.buildEmpty()
    const table1Name = 'table1'
    const table2Name = 'table2'

    engine.addSheet(table1Name)
    engine.setCellContents(adr('A1', engine.getSheetId(table1Name)), `='${table2Name}'!A1`)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(table1Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(table2Name)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(table2Name)))).toBeNull()
    expect(engine.getCellValue(adr('A1', engine.getSheetId(table1Name)))).toBeNull()

    engine.setCellContents(adr('A1', engine.getSheetId(table2Name)), 10)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(table1Name)))).toBe(10)
  })

  it('recalculates an aggregate function with range reference', () => {
    const engine = HyperFormula.buildEmpty()
    const sheet1Name = 'Sheet1'
    const sheet2Name = 'Sheet2'

    engine.addSheet(sheet1Name)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet1Name)), `=SUM('${sheet2Name}'!A1:B2)`)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(sheet2Name)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet2Name)))).toBeNull()
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(0)

    engine.setCellContents(adr('A1', engine.getSheetId(sheet2Name)), 10)
    engine.setCellContents(adr('B1', engine.getSheetId(sheet2Name)), 20)
    engine.setCellContents(adr('A2', engine.getSheetId(sheet2Name)), 30)
    engine.setCellContents(adr('B2', engine.getSheetId(sheet2Name)), 40)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(100)
  })

  it('recalculates chained dependencies across multiple sheets', () => {
    const engine = HyperFormula.buildEmpty()
    const sheet1Name = 'Sheet1'
    const sheet2Name = 'Sheet2'
    const sheet3Name = 'Sheet3'

    engine.addSheet(sheet1Name)
    engine.addSheet(sheet2Name)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet1Name)), `='${sheet2Name}'!A1+2`)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet2Name)), `='${sheet3Name}'!A1*2`)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet2Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(sheet3Name)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet3Name)))).toBeNull()
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet2Name)))).toBe(0)
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(2)

    engine.setCellContents(adr('A1', engine.getSheetId(sheet3Name)), 42)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet2Name)))).toBe(84)
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(86)
  })

  it('recalculates nested dependencies within same sheet', () => {
    const engine = HyperFormula.buildEmpty()
    const sheet1Name = 'Sheet1'
    const newSheetName = 'NewSheet'

    engine.addSheet(sheet1Name)
    engine.setCellContents(adr('B1', engine.getSheetId(sheet1Name)), `='${newSheetName}'!A1`)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet1Name)), '=B1*2')

    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(newSheetName)

    expect(engine.getCellValue(adr('B1', engine.getSheetId(newSheetName)))).toBeNull()
    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBeNull()
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(0)

    engine.setCellContents(adr('A1', engine.getSheetId(newSheetName)), 15)

    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(15)
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(30)
  })

  it('recalculates multiple cells from different sheets', () => {
    const engine = HyperFormula.buildEmpty()
    const sheet1Name = 'Sheet1'
    const sheet2Name = 'Sheet2'
    const targetSheetName = 'TargetSheet'

    engine.addSheet(sheet1Name)
    engine.addSheet(sheet2Name)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet1Name)), `='${targetSheetName}'!A1`)
    engine.setCellContents(adr('B1', engine.getSheetId(sheet1Name)), `='${targetSheetName}'!B1`)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet2Name)), `='${targetSheetName}'!A1+10`)
    engine.setCellContents(adr('B1', engine.getSheetId(sheet2Name)), `='${targetSheetName}'!B1+20`)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet2Name)))).toEqualError(detailedError(ErrorType.REF))
    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet2Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(targetSheetName)
    engine.setCellContents(adr('A1', engine.getSheetId(targetSheetName)), 5)
    engine.setCellContents(adr('B1', engine.getSheetId(targetSheetName)), 7)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(5)
    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(7)
    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet2Name)))).toBe(15)
    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet2Name)))).toBe(27)
  })

  it('recalculates formulas with mixed operations', () => {
    const engine = HyperFormula.buildEmpty()
    const sheet1Name = 'Sheet1'
    const newSheetName = 'NewSheet'

    engine.addSheet(sheet1Name)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet1Name)), 100)
    engine.setCellContents(adr('B1', engine.getSheetId(sheet1Name)), `='${newSheetName}'!A1 + A1`)
    engine.setCellContents(adr('C1', engine.getSheetId(sheet1Name)), `='${newSheetName}'!B1 * 2`)

    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
    expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(newSheetName)
    engine.setCellContents(adr('A1', engine.getSheetId(newSheetName)), 50)
    engine.setCellContents(adr('B1', engine.getSheetId(newSheetName)), 25)

    expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(150)
    expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(50)
  })

  it('recalculates formulas with range references', () => {
    const engine = HyperFormula.buildEmpty()
    const sheet1Name = 'Sheet1'
    const dataSheetName = 'DataSheet'

    engine.addSheet(sheet1Name)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet1Name)), `=SUM('${dataSheetName}'!A1:B5)`)
    engine.setCellContents(adr('A2', engine.getSheetId(sheet1Name)), `=MEDIAN('${dataSheetName}'!A1:B5)`)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
    expect(engine.getCellValue(adr('A2', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(dataSheetName)
    const dataSheetId = engine.getSheetId(dataSheetName)
    engine.setCellContents(adr('A1', dataSheetId), 1)
    engine.setCellContents(adr('B1', dataSheetId), 2)
    engine.setCellContents(adr('A2', dataSheetId), 3)
    engine.setCellContents(adr('B2', dataSheetId), 4)
    engine.setCellContents(adr('A3', dataSheetId), 5)
    engine.setCellContents(adr('B3', dataSheetId), 6)
    engine.setCellContents(adr('A4', dataSheetId), 7)
    engine.setCellContents(adr('B4', dataSheetId), 8)
    engine.setCellContents(adr('A5', dataSheetId), 9)
    engine.setCellContents(adr('B5', dataSheetId), 10)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(55)
    expect(engine.getCellValue(adr('A2', engine.getSheetId(sheet1Name)))).toBe(5.5)
  })

  it('recalculates named expressions', () => {
    const engine = HyperFormula.buildEmpty()
    const sheet1Name = 'Sheet1'
    const newSheetName = 'NewSheet'

    engine.addSheet(sheet1Name)
    engine.addNamedExpression('MyValue', `='${newSheetName}'!$A$1`)
    engine.setCellContents(adr('A1', engine.getSheetId(sheet1Name)), '=MyValue')
    engine.setCellContents(adr('A2', engine.getSheetId(sheet1Name)), '=MyValue*2')

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
    expect(engine.getCellValue(adr('A2', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

    engine.addSheet(newSheetName)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBeNull()
    expect(engine.getCellValue(adr('A2', engine.getSheetId(sheet1Name)))).toBe(0)

    engine.setCellContents(adr('A1', engine.getSheetId(newSheetName)), 99)

    expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(99)
    expect(engine.getCellValue(adr('A2', engine.getSheetId(sheet1Name)))).toBe(198)
  })

  describe('complex range scenarios', () => {
    it('function using `runFunction` (with array arithmetic off)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [['=MEDIAN(NewSheet!A1:A1)', '=MEDIAN(NewSheet!A1:A2)', '=MEDIAN(NewSheet!A1:A3)', '=MEDIAN(NewSheet!A1:A4)']]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: false})

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(1)
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(1.5)
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(2)
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toBe(2.5)
    })

    it('function using `runFunction` (with array arithmetic on)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [['=MEDIAN(NewSheet!A1:A1)', '=MEDIAN(NewSheet!A1:A2)', '=MEDIAN(NewSheet!A1:A3)', '=MEDIAN(NewSheet!A1:A4)']]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: true})

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(1)
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(1.5)
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(2)
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toBe(2.5)
    })

    it('function not using `runFunction` (with array arithmetic off)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [['=SUM(NewSheet!A1:A1)', '=SUM(NewSheet!A1:A2)', '=SUM(NewSheet!A1:A3)', '=SUM(NewSheet!A1:A4)']]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: false})

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(1)
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(3)
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(6)
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toBe(10)
    })

    it('function not using `runFunction` (with array arithmetic on)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [['=SUM(NewSheet!A1:A1)', '=SUM(NewSheet!A1:A2)', '=SUM(NewSheet!A1:A3)', '=SUM(NewSheet!A1:A4)']]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: true})

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(1)
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(3)
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(6)
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toBe(10)
    })

    it('function using `runFunction` referencing range indirectly (with array arithmetic off)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [
        ['=MEDIAN(A2)', '=MEDIAN(B2)', '=MEDIAN(C2)', '=MEDIAN(D2)'],
        [`='${sheet2Name}'!A1:A1`, `='${sheet2Name}'!A1:B2`, `='${sheet2Name}'!A1:A3`, `='${sheet2Name}'!A1:A4`],
    ]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: false})

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(1)
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(1.5)
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(2)
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toBe(2.5)
    })

    it('function using `runFunction` referencing range indirectly (with array arithmetic on)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [
        ['=MEDIAN(A2)', '=MEDIAN(B2)', '=MEDIAN(C2)', '=MEDIAN(D2)'],
        [`='${sheet2Name}'!A1:A1`, `='${sheet2Name}'!A1:B2`, `='${sheet2Name}'!A1:A3`, `='${sheet2Name}'!A1:A4`],
    ]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: true})

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(1)
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(1.5)
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(2)
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toBe(2.5)
    })

    it('function not using `runFunction` referencing range indirectly (with array arithmetic off)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [
        ['=SUM(A2)', '=SUM(B2)', '=SUM(C2)', '=SUM(D2)'],
        [`='${sheet2Name}'!A1:A1`, `='${sheet2Name}'!A1:B2`, `='${sheet2Name}'!A1:A3`, `='${sheet2Name}'!A1:A4`],
    ]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: false})

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(1)
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(3)
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(6)
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toBe(10)
    })

    it('function not using `runFunction` referencing range indirectly (with array arithmetic on)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [
        ['=SUM(A2)', '=SUM(B2)', '=SUM(C2)', '=SUM(D2)'],
        [`='${sheet2Name}'!A1:A1`, `='${sheet2Name}'!A1:B2`, `='${sheet2Name}'!A1:A3`, `='${sheet2Name}'!A1:A4`],
    ]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: true})

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getCellValue(adr('A1', engine.getSheetId(sheet1Name)))).toBe(1)
      expect(engine.getCellValue(adr('B1', engine.getSheetId(sheet1Name)))).toBe(3)
      expect(engine.getCellValue(adr('C1', engine.getSheetId(sheet1Name)))).toBe(6)
      expect(engine.getCellValue(adr('D1', engine.getSheetId(sheet1Name)))).toBe(10)
    })

    it('function calling a named expression (with array arithmetic off)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [[`='${sheet2Name}'!A1:A4`]]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: false}, [
        { name: 'ExprA', expression: `=MEDIAN(${sheet2Name}!$A$1:$A$1)` },
        { name: 'ExprB', expression: `=MEDIAN(${sheet2Name}!$A$1:$A$2)` },
        { name: 'ExprC', expression: `=MEDIAN(${sheet2Name}!$A$1:$A$3)` },
        { name: 'ExprD', expression: `=MEDIAN(${sheet1Name}!$A$1)` }
      ])

      expect(engine.getNamedExpressionValue('ExprA')).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getNamedExpressionValue('ExprB')).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getNamedExpressionValue('ExprC')).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getNamedExpressionValue('ExprD')).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getNamedExpressionValue('ExprA')).toBe(1)
      expect(engine.getNamedExpressionValue('ExprB')).toBe(1.5)
      expect(engine.getNamedExpressionValue('ExprC')).toBe(2)
      expect(engine.getNamedExpressionValue('ExprD')).toBe(2.5)
    })

    it('function calling a named expression (with array arithmetic on)', () => {
      const sheet1Name = 'FirstSheet'
      const sheet2Name = 'NewSheet'
      const sheet1Data = [[`='${sheet2Name}'!A1:A4`]]
      const sheet2Data = [[1], [2], [3], [4]]
      const engine = HyperFormula.buildFromSheets({
        [sheet1Name]: sheet1Data,
      }, {useArrayArithmetic: true}, [
        { name: 'ExprA', expression: `=MEDIAN(${sheet2Name}!$A$1:$A$1)` },
        { name: 'ExprB', expression: `=MEDIAN(${sheet2Name}!$A$1:$A$2)` },
        { name: 'ExprC', expression: `=MEDIAN(${sheet2Name}!$A$1:$A$3)` },
        { name: 'ExprD', expression: `=MEDIAN(${sheet1Name}!$A$1)` }
      ])

      expect(engine.getNamedExpressionValue('ExprA')).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getNamedExpressionValue('ExprB')).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getNamedExpressionValue('ExprC')).toEqualError(detailedError(ErrorType.REF))
      expect(engine.getNamedExpressionValue('ExprD')).toEqualError(detailedError(ErrorType.REF))

      engine.addSheet(sheet2Name)
      engine.setSheetContent(engine.getSheetId(sheet2Name)!, sheet2Data)

      expect(engine.getNamedExpressionValue('ExprA')).toBe(1)
      expect(engine.getNamedExpressionValue('ExprB')).toBe(1.5)
      expect(engine.getNamedExpressionValue('ExprC')).toBe(2)
      expect(engine.getNamedExpressionValue('ExprD')).toBe(2.5)
    })
  })
})

// IMPLEMENTATION PLAN:
// - [x] during parseing dont create ERROR vertex - instead add a placeholder shett to sheetMapping and addressMapping
// - [x] handle this non-error vertec when reading cell (similar to not-added named expressions?)
// - [x] unit tests: addSheet + ranges, with and without quotes
// - [x] handle addSheet
// - [x] comprehensive range testing
// - [ ] unit tests: removeSheet + ranges
// - [ ] handle removeSheet
// - [ ] unit tests: renameSheet + ranges
// - [ ] handle renameSheet
// - [ ] refactor
// - [ ] unit tests: undo-redo
// - [ ] handle undo-redo
