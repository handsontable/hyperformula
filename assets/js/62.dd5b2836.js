(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{356:function(e,a,t){"use strict";t.r(a);var r=t(14),s=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"key-concepts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key-concepts"}},[e._v("#")]),e._v(" Key concepts")]),e._v(" "),a("h2",{attrs:{id:"high-level-design-diagram"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#high-level-design-diagram"}},[e._v("#")]),e._v(" High-level design diagram")]),e._v(" "),a("img",{attrs:{src:e.$withBase("/hf-high-lvl-diagram.svg")}}),e._v(" "),a("p",[e._v("Data processing consists of three phases.")]),e._v(" "),a("h2",{attrs:{id:"phase-1-parsing-and-construction-of-asts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#phase-1-parsing-and-construction-of-asts"}},[e._v("#")]),e._v(" Phase 1. Parsing and construction of ASTs")]),e._v(" "),a("p",[e._v("Formulas need to be parsed and represented as a\nso-called\n"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree",target:"_blank",rel:"noopener noreferrer"}},[e._v("Abstract Syntax Tree"),a("OutboundLink")],1),e._v("\n(AST). For example, the AST for "),a("code",[e._v("7*3-SIN(A5)")]),e._v(" will look\nsimilar to this graph:")]),e._v(" "),a("img",{attrs:{src:e.$withBase("/ast.png")}}),e._v(" "),a("h2",{attrs:{id:"phase-2-construction-of-the-dependency-graph"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#phase-2-construction-of-the-dependency-graph"}},[e._v("#")]),e._v(" Phase 2. Construction of the dependency graph")]),e._v(" "),a("p",[e._v("HyperFormula needs to understand the relationship between cells and\nfind the right order of processing them. For example, for a sample\nformula "),a("code",[e._v("C1=A1+B1")]),e._v(", it needs to process first "),a("code",[e._v("A1")]),e._v(" and "),a("code",[e._v("B1")]),e._v(" and\nthen "),a("code",[e._v("C1")]),e._v(". Such an order of processing cells - also known as\n"),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Topological_sorting",target:"_blank",rel:"noopener noreferrer"}},[e._v("topological order"),a("OutboundLink")],1),e._v("\nexists if and only if there is no cycle in the dependency graph.")]),e._v(" "),a("p",[e._v("There can be many such orders, like so:")]),e._v(" "),a("img",{attrs:{src:e.$withBase("/topsort.png")}}),e._v(" "),a("p",[e._v("Read more about the "),a("RouterLink",{attrs:{to:"/guide/dependency-graph.html"}},[e._v("dependency graph")]),e._v(".")],1),e._v(" "),a("h2",{attrs:{id:"phase-3-evaluation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#phase-3-evaluation"}},[e._v("#")]),e._v(" Phase 3. Evaluation")]),e._v(" "),a("p",[e._v("It is crucial to evaluate cells efficiently. For simple expressions,\nthere is not much room for maneuver, but spreadsheet-like data sets\ndefinitely need more attention.")]),e._v(" "),a("img",{attrs:{src:e.$withBase("/sample-sheet.png")}}),e._v(" "),a("h2",{attrs:{id:"grammar"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#grammar"}},[e._v("#")]),e._v(" Grammar")]),e._v(" "),a("p",[e._v("For parsing purposes, the library uses the\n"),a("a",{attrs:{href:"http://sap.github.io/chevrotain/docs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Chevrotain"),a("OutboundLink")],1),e._v(" parser, which turns\nout to be more efficient than popular "),a("a",{attrs:{href:"https://zaa.ch/jison/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Jison"),a("OutboundLink")],1),e._v(".\nThe language of acceptable formulas is described with an LL(k) grammar\nusing Chevrotain Domain Specific Language. See details of the grammar\nin the\n"),a("a",{attrs:{href:"https://github.com/handsontable/hyperformula/blob/master/src/parser/FormulaParser.ts",target:"_blank",rel:"noopener noreferrer"}},[e._v("FormulaParser"),a("OutboundLink")],1),e._v("\nfile.")]),e._v(" "),a("h2",{attrs:{id:"repetitive-asts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#repetitive-asts"}},[e._v("#")]),e._v(" Repetitive ASTs")]),e._v(" "),a("p",[e._v("A first natural optimization could concern cells in a spreadsheet which\nstore exactly the same formulas. For such cells, there is no point in\nconstructing and storing two ASTs which would be the same in the end.\nInstead, HyperFormula can look up the particular formula that has\nalready been parsed and reuse the constructed AST.")]),e._v(" "),a("p",[e._v("A scenario with repeating formulas is somewhat idealized; in practice,\nmost formulas will be distinct. Fortunately, formulas in spreadsheets\nusually have a defined structure and share some patterns. Neighboring\ncells often contain similar formulas, especially after filling cells\nusing a fill handle (that little square in the bottom right corner of\na visual cell representation). For example:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("B2=A2-C2+B1")])]),e._v(" "),a("li",[a("code",[e._v("B3=A3-C3+B2")])]),e._v(" "),a("li",[a("code",[e._v("B4=A4-C4+B3")])]),e._v(" "),a("li",[a("code",[e._v("B5=A5-C5+B4")])]),e._v(" "),a("li",[e._v("and so on...")])]),e._v(" "),a("p",[e._v("Although the exact ASTs for these formulas are different, they share a\ncommon pattern. A very useful approach here is to rewrite a formula using\nrelative addressing of cells.")]),e._v(" "),a("h2",{attrs:{id:"relative-addressing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#relative-addressing"}},[e._v("#")]),e._v(" Relative addressing")]),e._v(" "),a("p",[e._v("HyperFormula stores the offset to the referenced formula. For example\n"),a("code",[e._v("B2=B5 + C1")]),e._v(" can be rewritten as "),a("code",[e._v("B2=[B+0][2+3] + [B+1][2-1]")]),e._v(" or in short\n"),a("code",[e._v("B2=[0][+3] + [+1][-1]")]),e._v(". Then, the above example with "),a("code",[e._v("B2,B3")]),e._v(",  and "),a("code",[e._v("B4")]),e._v("\ncan be rewritten as "),a("code",[e._v("B2=B3=B4=[-1][0] - [1][0] + [0][-1]")]),e._v(". Now the three\ncells have exactly the same formulas.")]),e._v(" "),a("p",[e._v("By using relative addressing HyperFormula unifies formulas from many\ncells. Thanks to that, there is no need to parse them all\nover again. Also, with this approach, the engine doesn't lose any\ninformation because by knowing the absolute address of a cell and its\nformula with relative addresses, it can easily retrieve the absolute\naddresses and compute the result.")]),e._v(" "),a("h2",{attrs:{id:"laziness-of-crud-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#laziness-of-crud-operations"}},[e._v("#")]),e._v(" Laziness of CRUD operations")]),e._v(" "),a("p",[e._v("After each CRUD operation, like adding a row or column or moving\ncells, references inside formulas may need to be changed. For example,\nafter adding a row, we need to shift all references in the formulas\nbelow like so:")]),e._v(" "),a("img",{attrs:{src:e.$withBase("/crud-operations.png")}}),e._v(" "),a("p",[e._v("In more complex sheets this can lead to similar transformations in\nmany formulas at once. On the other hand, such operations do not\nrequire an immediate transformation of all the affected formulas.")]),e._v(" "),a("p",[e._v("Instead of transforming all of them at once, HyperFormula remembers\nthe history of the operations and postpones the transformations\nuntil the formula needs to be displayed or recalculated.")])])}),[],!1,null,null,null);a.default=s.exports}}]);